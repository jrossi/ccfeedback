package linters

import (
	"context"
	"strings"
	"testing"
)

func TestGoLinter_CanHandle(t *testing.T) {
	linter := NewGoLinter()

	tests := []struct {
		filePath string
		want     bool
	}{
		{"main.go", true},
		{"test.go", true},
		{"foo/bar/baz.go", true},
		{"main_test.go", true},
		{"README.md", false},
		{"script.sh", false},
		{"test.txt", false},
		{"test.golang", false},
	}

	for _, tt := range tests {
		t.Run(tt.filePath, func(t *testing.T) {
			if got := linter.CanHandle(tt.filePath); got != tt.want {
				t.Errorf("CanHandle(%q) = %v, want %v", tt.filePath, got, tt.want)
			}
		})
	}
}

func TestGoLinter_Lint_Formatting(t *testing.T) {
	linter := NewGoLinter()
	ctx := context.Background()

	tests := []struct {
		name    string
		content string
		wantErr bool
		wantFmt bool
	}{
		{
			name: "properly formatted",
			content: `package main

import "fmt"

func main() {
	fmt.Println("Hello, World!")
}
`,
			wantErr: false,
			wantFmt: false,
		},
		{
			name: "needs formatting",
			content: `package main

import "fmt"

func main() {
fmt.Println("Hello, World!")
}
`,
			wantErr: false,
			wantFmt: true,
		},
		{
			name: "syntax error",
			content: `package main

func main() {
	fmt.Println("Missing import"
}
`,
			wantErr: true,
			wantFmt: false,
		},
		{
			name: "generated file",
			content: `// Code generated by mockgen. DO NOT EDIT.
package main

func main() {
fmt.Println("Unformatted but generated")
}
`,
			wantErr: false,
			wantFmt: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result, err := linter.Lint(ctx, "test.go", []byte(tt.content))
			if err != nil {
				t.Fatalf("Lint() error = %v", err)
			}

			if tt.wantErr && result.Success {
				t.Errorf("expected error but got success")
			}

			if !tt.wantErr && !result.Success && !tt.wantFmt {
				t.Errorf("unexpected failure: %v", result.Issues)
			}

			if tt.wantFmt && result.Formatted == nil {
				t.Errorf("expected formatted output but got none")
			}

			if !tt.wantFmt && result.Formatted != nil {
				t.Errorf("unexpected formatted output")
			}
		})
	}
}

func TestGoLinter_SkipTestData(t *testing.T) {
	linter := NewGoLinter()
	ctx := context.Background()

	content := `package testdata

func unformattedFunc() {
fmt.Println("This should be skipped")
}
`

	result, err := linter.Lint(ctx, "/path/to/testdata/test.go", []byte(content))
	if err != nil {
		t.Fatalf("Lint() error = %v", err)
	}

	if !result.Success {
		t.Errorf("testdata file should be skipped, but got failure")
	}

	if len(result.Issues) > 0 {
		t.Errorf("testdata file should have no issues, but got %v", result.Issues)
	}
}

func TestGoLinter_FindModuleRoot(t *testing.T) {
	// This test would need a real filesystem setup
	// For now, we'll just test that the method exists
	// In a real test, we'd create temporary directories with go.mod files

	t.Skip("Skipping filesystem-dependent test")
}

func TestGoLinter_FormatFile(t *testing.T) {
	linter := NewGoLinter()

	input := []byte(`package main
import "fmt"
func main(){
fmt.Println("Hello")
}`)

	formatted, err := linter.FormatFile(input)
	if err != nil {
		t.Fatalf("FormatFile() error = %v", err)
	}

	// Check that it's properly formatted
	if !strings.Contains(string(formatted), "\t") {
		t.Errorf("expected formatted code to contain tabs")
	}

	// Check that the import and function are on separate lines
	lines := strings.Split(string(formatted), "\n")
	if len(lines) < 6 {
		t.Errorf("expected at least 6 lines in formatted code, got %d", len(lines))
	}
}
