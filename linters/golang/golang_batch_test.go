package golang

import (
	"context"
	"testing"
)

func TestGoLinter_LintBatch(t *testing.T) {
	linter := NewGoLinter()
	ctx := context.Background()

	// Test files with various conditions
	files := map[string][]byte{
		"/tmp/test1.go": []byte(`package main

func main() {
	// Missing closing brace
	if true {
		fmt.Println("Hello")
}`),
		"/tmp/test2.go": []byte(`package main

import "fmt"

func main() {
	fmt.Println("Hello, World!")
}
`),
		"/tmp/generated.go": []byte(`// Code generated by tool. DO NOT EDIT.
package main

func main() {}
`),
		"/tmp/testdata/test.go": []byte(`package main

func main() {}
`),
	}

	results, err := linter.LintBatch(ctx, files)
	if err != nil {
		t.Fatalf("LintBatch failed: %v", err)
	}

	// Check results exist for all files
	if len(results) != len(files) {
		t.Errorf("expected results for %d files, got %d", len(files), len(results))
	}

	// Test1.go should have a syntax error (fmt not imported)
	if result, exists := results["/tmp/test1.go"]; exists {
		if result.Success {
			t.Error("expected test1.go to have syntax error")
		}
		foundSyntaxError := false
		for _, issue := range result.Issues {
			if issue.Rule == "syntax" {
				foundSyntaxError = true
				break
			}
		}
		if !foundSyntaxError {
			t.Error("expected syntax error for test1.go")
		}
	} else {
		t.Error("missing results for test1.go")
	}

	// Test2.go should be successful (valid Go code)
	if result, exists := results["/tmp/test2.go"]; exists {
		// Check for syntax errors only
		for _, issue := range result.Issues {
			if issue.Severity == "error" && issue.Rule == "syntax" {
				t.Errorf("unexpected syntax error in test2.go: %s", issue.Message)
			}
		}
	} else {
		t.Error("missing results for test2.go")
	}

	// Generated file should have no issues
	if result, exists := results["/tmp/generated.go"]; exists {
		if len(result.Issues) > 0 {
			t.Errorf("expected no issues for generated file, got %d", len(result.Issues))
		}
	} else {
		t.Error("missing results for generated.go")
	}

	// Testdata file should have no issues
	if result, exists := results["/tmp/testdata/test.go"]; exists {
		if len(result.Issues) > 0 {
			t.Errorf("expected no issues for testdata file, got %d", len(result.Issues))
		}
	} else {
		t.Error("missing results for testdata file")
	}
}

func TestGoLinter_LintBatchEmptyFiles(t *testing.T) {
	linter := NewGoLinter()
	results, err := linter.LintBatch(context.Background(), map[string][]byte{})

	if err != nil {
		t.Errorf("expected no error for empty files, got: %v", err)
	}

	if len(results) != 0 {
		t.Errorf("expected empty results, got %d", len(results))
	}
}

func TestGoLinter_LintBatchFormatting(t *testing.T) {
	linter := NewGoLinter()

	// Poorly formatted Go code
	files := map[string][]byte{
		"/tmp/unformatted.go": []byte(`package main
import "fmt"
func main(){fmt.Println("Hello")}`),
	}

	results, err := linter.LintBatch(context.Background(), files)
	if err != nil {
		t.Fatalf("LintBatch failed: %v", err)
	}

	result := results["/tmp/unformatted.go"]
	if result == nil {
		t.Fatal("missing result for unformatted.go")
	}

	// Should have formatting issue
	foundFormattingIssue := false
	for _, issue := range result.Issues {
		if issue.Rule == "gofmt" {
			foundFormattingIssue = true
			break
		}
	}

	if !foundFormattingIssue {
		t.Error("expected gofmt warning for unformatted code")
	}

	// Should have formatted version
	if result.Formatted == nil {
		t.Error("expected formatted version of code")
	}
}
